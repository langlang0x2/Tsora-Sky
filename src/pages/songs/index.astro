---
import { getCollection } from 'astro:content'

import { Button } from 'astro-pure/user'
import PageLayout from '@/layouts/BaseLayout.astro'

export const prerender = true

const allSongs = (await getCollection('songs')).filter((s) => !s.data.draft)
const songs = [...allSongs].sort(
  (a, b) => b.data.collectDate.getTime() - a.data.collectDate.getTime()
)

const tagCount = new Map<string, number>()
for (const song of songs) {
  for (const tag of song.data.tags) {
    tagCount.set(tag, (tagCount.get(tag) ?? 0) + 1)
  }
}
const allTags = [...tagCount.entries()].sort(([a], [b]) => a.localeCompare(b, 'zh-CN'))

function formatYearMonth(date: Date) {
  const year = date.getFullYear()
  const month = String(date.getMonth() + 1).padStart(2, '0')
  return `${year}-${month}`
}

const baseUrl = import.meta.env.BASE_URL
const songsData = songs.map((song) => {
  const videoUrl =
    song.data.videoUrl ??
    (song.data.bvid
      ? `https://www.bilibili.com/video/${song.data.bvid}/`
      : '#')
  const coverRaw = song.data.cover ?? '/images/social-card.png'
  const coverHttps = coverRaw.startsWith('http://')
    ? `https://${coverRaw.slice('http://'.length)}`
    : coverRaw
  const cover = coverHttps.startsWith('/')
    ? `${baseUrl}${coverHttps.slice(1)}`
    : coverHttps
  const title = song.data.title ?? (song.data.bvid ? `（未同步）${song.data.bvid}` : song.id)

  return {
    id: song.id,
    statKey: song.data.bvid ?? song.id,
    title,
    note: song.data.note ?? '',
    tags: song.data.tags,
    videoUrl,
    cover,
    collectTs: song.data.collectDate.getTime(),
    collectDate: song.data.collectDate.toISOString().slice(0, 10),
    ym: formatYearMonth(song.data.collectDate)
  }
})

const meta = {
  title: 'Sound',
  description: '带封面与标签的歌曲收藏，点击卡片直达视频。'
}
---

<PageLayout {meta}>
  <main class='mt-6 lg:mt-10'>
    <div id='content-header' class='animate'>
      <h1 class='mb-2 text-3xl font-medium'>Sound</h1>
      <p class='text-muted-foreground'>点击会在新标签页打开视频，并在本机记录观看次数。</p>
      <p class='mt-3'>总观看次数：<samp id='total-clicks'>0</samp></p>
      <div class='mt-4 flex flex-wrap gap-3' aria-label='Sort mode'>
        <Button href='#' variant='pill' data-sort-mode='date'>按收藏时间</Button>
        <Button href='#' variant='pill' data-sort-mode='plays'>按播放量</Button>
      </div>
      <div class='mt-4 rounded-2xl border bg-muted p-3'>
        <label for='songs-search-input' class='text-sm text-muted-foreground'>搜索（标题 / 备注 / 标签）</label>
        <input
          id='songs-search-input'
          type='search'
          placeholder='例如：Ado、日语、翻唱'
          class='mt-2 w-full rounded-xl border bg-background px-3 py-2 text-sm outline-none ring-offset-background focus-visible:ring-2 focus-visible:ring-ring'
        />
        <p id='songs-search-summary' class='mt-2 text-sm text-muted-foreground'>共 {songs.length} 首</p>
      </div>
    </div>

    <div class='mt-6 flex flex-wrap gap-3 animate' aria-label='Tags'>
      <Button href='#' variant='pill' class='items-start gap-x-1' data-tag-reset='1'>
        全部
        <span class='text-xs'>{songs.length}</span>
      </Button>
      {
        allTags.map(([tag, count]) => (
          <Button
            href='#'
            variant='pill'
            class='items-start gap-x-1'
            data-filter-tag={tag}
            data-filter-state='0'
          >
            {tag}
            <span class='text-xs'>{count}</span>
          </Button>
        ))
      }
    </div>

    <section id='content' class='animate mt-8' aria-label='Song list'>
      {
        songs.length === 0 ? (
          <p>暂无收藏。</p>
        ) : (
          <>
            <div data-song-groups></div>

            <div id='song-flat-wrap' class='mt-12 hidden'>
              <h2 class='text-2xl font-medium'>按播放量排序</h2>
              <ul
                id='song-flat-list'
                class='mt-4 song-grid'
                data-song-flat-list
              />
            </div>

            <p id='songs-empty-tip' class='mt-6 hidden text-muted-foreground'>没有匹配的收藏。</p>

            <div id='songs-load-sentinel' class='h-1 w-full' aria-hidden='true'></div>
            <p id='songs-load-status' class='mt-4 text-sm text-muted-foreground'>加载中…</p>
          </>
        )
      }
    </section>
  </main>

  <script is:inline define:vars={{ SONGS: songsData }}>
    const SORT_MODE_KEY = 'tsora-songs-sort-mode-v1'
    const STATS_API = '/api/songs/stats'
    const TAG_API = '/api/songs/tag'
    const PAGE_SIZE = 24

    let clickMap = {}
    let activeMode = 'date'
    let isReverseOrder = false
    let searchQuery = ''
    let tagFilterState = new Map()
    let filteredSongs = SONGS
    let dateSortedSongs = filteredSongs
    let dateCursor = 0
    let playCursor = 0
    let playSortedSongs = []
    let monthListMap = new Map()
    let observer = null
    const TAG_INCLUDE_CLASSES = ['text-orange-700', 'border-orange-500/55', 'bg-orange-500/20', 'dark:text-orange-300']
    const TAG_EXCLUDE_CLASSES = ['text-blue-700', 'border-blue-500/55', 'bg-blue-500/15', 'dark:text-blue-300']
    const SORT_NORMAL_CLASSES = ['text-orange-700', 'border-orange-500/55', 'bg-orange-500/20', 'dark:text-orange-300']
    const SORT_REVERSE_CLASSES = ['text-blue-700', 'border-blue-500/55', 'bg-blue-500/15', 'dark:text-blue-300']

    function loadSortMode() {
      try {
        const raw = localStorage.getItem(SORT_MODE_KEY)
        return raw === 'plays' ? 'plays' : 'date'
      } catch {
        return 'date'
      }
    }

    function saveSortMode(mode) {
      try {
        localStorage.setItem(SORT_MODE_KEY, mode)
      } catch {
        // ignore
      }
    }

    function getSongIds() {
      return SONGS
        .map((song) => song.statKey)
        .filter((id) => typeof id === 'string' && id.length > 0)
    }

    function normalizeText(value) {
      return String(value ?? '')
        .toLowerCase()
        .replace(/\s+/g, '')
    }

    function buildSongSearchText(song) {
      const tagsText = Array.isArray(song.tags) ? song.tags.join(' ') : ''
      return normalizeText(`${song.title} ${song.note} ${tagsText}`)
    }

    function getTagLists() {
      const include = []
      const exclude = []
      for (const [tag, state] of tagFilterState.entries()) {
        if (state === 1) include.push(tag)
        else if (state === -1) exclude.push(tag)
      }
      return { include, exclude }
    }

    function hasAnyTagFilter() {
      for (const state of tagFilterState.values()) {
        if (state === 1 || state === -1) return true
      }
      return false
    }

    function matchesTagFilter(song) {
      const songTags = new Set(
        (Array.isArray(song.tags) ? song.tags : []).map((tag) => String(tag).toLowerCase())
      )
      const { include, exclude } = getTagLists()

      if (include.length > 0) {
        const hasIncluded = include.some((tag) => songTags.has(String(tag).toLowerCase()))
        if (!hasIncluded) return false
      }

      if (exclude.length > 0) {
        const hasExcluded = exclude.some((tag) => songTags.has(String(tag).toLowerCase()))
        if (hasExcluded) return false
      }

      return true
    }

    function applyTagClass(el, classNames, enabled) {
      for (const name of classNames) {
        el.classList.toggle(name, enabled)
      }
    }

    function updateTagFilterUI() {
      const controls = document.querySelectorAll('a[data-filter-tag]')
      controls.forEach((el) => {
        const tag = String(el.getAttribute('data-filter-tag') ?? '')
        const state = Number(tagFilterState.get(tag) ?? 0)

        el.setAttribute('data-filter-state', String(state))
        el.setAttribute('aria-pressed', state === 0 ? 'false' : 'true')
        applyTagClass(el, TAG_INCLUDE_CLASSES, state === 1)
        applyTagClass(el, TAG_EXCLUDE_CLASSES, state === -1)
      })

      const reset = document.querySelector('a[data-tag-reset]')
      if (reset instanceof HTMLElement) {
        const enabled = !hasAnyTagFilter()
        reset.setAttribute('aria-current', enabled ? 'page' : 'false')
      }
    }

    function recomputeFilteredSongs() {
      const keyword = normalizeText(searchQuery)
      filteredSongs = SONGS.filter((song) => {
        const keywordOk = keyword ? buildSongSearchText(song).includes(keyword) : true
        if (!keywordOk) return false
        return matchesTagFilter(song)
      })
    }

    function applySearch(query) {
      searchQuery = String(query ?? '')
      recomputeFilteredSongs()
      updateSearchSummary()
      applySort(activeMode, clickMap)
    }

    function updateSearchSummary() {
      const summary = document.getElementById('songs-search-summary')
      if (!(summary instanceof HTMLElement)) return

      const total = SONGS.length
      const current = filteredSongs.length
      const keyword = searchQuery.trim()
      const { include, exclude } = getTagLists()
      const includeText = include.length > 0 ? `选中：${include.join('、')}` : ''
      const excludeText = exclude.length > 0 ? `反选：${exclude.join('、')}` : ''
      const tagText = [includeText, excludeText].filter(Boolean).join('；')
      const baseText = keyword ? `关键词“${keyword}”：${current} / ${total} 首` : `共 ${current} / ${total} 首`
      summary.textContent = tagText ? `${baseText}（${tagText}）` : baseText
    }

    function getActiveSongs() {
      return filteredSongs
    }

    function updateEmptyState() {
      const emptyTip = document.getElementById('songs-empty-tip')
      const sentinel = document.getElementById('songs-load-sentinel')
      if (!(emptyTip instanceof HTMLElement)) return

      const isEmpty = getActiveSongs().length === 0
      emptyTip.classList.toggle('hidden', !isEmpty)
      if (sentinel instanceof HTMLElement) sentinel.classList.toggle('hidden', isEmpty)
    }

    function getCountBySong(song, map = clickMap) {
      const val = Number(map[song.statKey] ?? 0)
      return Number.isFinite(val) ? val : 0
    }

    function updateTotalText(map = clickMap) {
      let total = 0
      for (const key in map) {
        const val = Number(map[key])
        if (Number.isFinite(val)) total += val
      }

      const totalEl = document.getElementById('total-clicks')
      if (totalEl) totalEl.textContent = String(total)
    }

    function createSongCard(song, map = clickMap) {
      const li = document.createElement('li')
      li.className = 'h-full'
      li.dataset.collectTs = String(song.collectTs)

      const link = document.createElement('a')
      link.className =
        'group flex h-full flex-col overflow-hidden rounded-2xl border bg-muted p-2.5 transition-all hover:border-foreground/25 hover:shadow-sm sm:p-3'
      link.href = song.videoUrl
      link.target = '_blank'
      link.rel = 'noreferrer'
      link.dataset.songId = song.statKey

      const media = document.createElement('div')
      media.className = 'relative aspect-video w-full overflow-hidden rounded-xl bg-background'

      const img = document.createElement('img')
      img.src = song.cover
      img.alt = song.title
      img.loading = 'lazy'
      img.decoding = 'async'
      img.className = 'absolute inset-0 h-full w-full object-cover'
      img.onerror = () => {
        img.onerror = null
        img.src = '/images/social-card.png'
      }
      media.appendChild(img)

      const body = document.createElement('div')
      body.className = 'min-w-0 mt-2.5 flex flex-1 flex-col'

      const title = document.createElement('h3')
      title.className = 'line-clamp-2 text-base font-medium sm:text-lg'
      title.textContent = song.title
      body.appendChild(title)

      if (song.note) {
        const note = document.createElement('p')
        note.className = 'mt-1 line-clamp-2 text-sm text-muted-foreground'
        note.textContent = song.note
        body.appendChild(note)
      }

      const meta = document.createElement('div')
      meta.className =
        'mt-auto pt-2 flex flex-wrap items-center gap-x-3 gap-y-1 text-sm text-muted-foreground'

      const date = document.createElement('span')
      date.textContent = `收藏于 ${song.collectDate}`
      meta.appendChild(date)

      const dot = document.createElement('span')
      dot.className = 'select-none'
      dot.textContent = '·'
      meta.appendChild(dot)

      const playText = document.createElement('span')
      playText.textContent = '观看次数：'
      const playCount = document.createElement('samp')
      playCount.dataset.clickCount = '1'
      playCount.textContent = String(getCountBySong(song, map))
      playText.appendChild(playCount)
      meta.appendChild(playText)

      if (Array.isArray(song.tags) && song.tags.length > 0) {
        const tags = document.createElement('span')
        tags.className = 'truncate'
        tags.textContent = `标签：${song.tags.join('、')}`
        meta.appendChild(tags)
      }

      body.appendChild(meta)
      link.appendChild(media)
      link.appendChild(body)
      li.appendChild(link)
      return li
    }

    function updateVisibleCounts(map = clickMap) {
      const links = document.querySelectorAll('a[data-song-id]')
      links.forEach((a) => {
        const id = a.getAttribute('data-song-id')
        const count = Number(map[id] ?? 0)
        const el = a.querySelector('[data-click-count]')
        if (el) el.textContent = String(Number.isFinite(count) ? count : 0)
      })
    }

    function setSortUI(mode) {
      const controls = document.querySelectorAll('a[data-sort-mode]')
      controls.forEach((el) => {
        const currentMode = el.getAttribute('data-sort-mode')
        const current = currentMode === mode
        if (current) el.setAttribute('aria-current', 'page')
        else el.removeAttribute('aria-current')

        applyTagClass(el, SORT_NORMAL_CLASSES, current && !isReverseOrder)
        applyTagClass(el, SORT_REVERSE_CLASSES, current && isReverseOrder)
      })
    }

    function showDateGroups() {
      const groups = document.querySelector('[data-song-groups]')
      const flatWrap = document.getElementById('song-flat-wrap')
      if (groups instanceof HTMLElement) groups.classList.remove('hidden')
      if (flatWrap instanceof HTMLElement) flatWrap.classList.add('hidden')
    }

    function showPlaySortedFlat() {
      const groups = document.querySelector('[data-song-groups]')
      const flatWrap = document.getElementById('song-flat-wrap')
      if (groups instanceof HTMLElement) groups.classList.add('hidden')
      if (flatWrap instanceof HTMLElement) flatWrap.classList.remove('hidden')
    }

    function clearDateGroups() {
      const groups = document.querySelector('[data-song-groups]')
      if (groups instanceof HTMLElement) groups.innerHTML = ''
      monthListMap = new Map()
    }

    function getOrCreateMonthList(ym) {
      const cached = monthListMap.get(ym)
      if (cached instanceof HTMLUListElement) return cached

      const groups = document.querySelector('[data-song-groups]')
      if (!(groups instanceof HTMLElement)) return null

      const section = document.createElement('div')
      section.className = 'mt-12'
      section.dataset.ym = ym

      const h2 = document.createElement('h2')
      h2.className = 'text-2xl font-medium'
      h2.textContent = ym

      const ul = document.createElement('ul')
      ul.className = 'mt-4 song-grid'

      section.appendChild(h2)
      section.appendChild(ul)
      groups.appendChild(section)
      monthListMap.set(ym, ul)
      return ul
    }

    function resetDateRender(map = clickMap) {
      dateCursor = 0
      clearDateGroups()
      updateEmptyState()
      loadNextDateBatch(map)
    }

    function loadNextDateBatch(map = clickMap) {
      if (dateCursor >= dateSortedSongs.length) return

      const next = dateSortedSongs.slice(dateCursor, dateCursor + PAGE_SIZE)
      for (const song of next) {
        const monthList = getOrCreateMonthList(song.ym)
        if (!monthList) continue
        monthList.appendChild(createSongCard(song, map))
      }
      dateCursor += next.length
    }

    function resetPlayRender(map = clickMap) {
      playCursor = 0
      const flatList = document.querySelector('[data-song-flat-list]')
      if (flatList instanceof HTMLElement) flatList.innerHTML = ''
      updateEmptyState()
      loadNextPlayBatch(map)
    }

    function loadNextPlayBatch(map = clickMap) {
      const flatList = document.querySelector('[data-song-flat-list]')
      if (!(flatList instanceof HTMLElement)) return
      if (playCursor >= playSortedSongs.length) return

      const next = playSortedSongs.slice(playCursor, playCursor + PAGE_SIZE)
      for (const song of next) {
        flatList.appendChild(createSongCard(song, map))
      }
      playCursor += next.length
    }

    function hasMore() {
      return activeMode === 'plays'
        ? playCursor < playSortedSongs.length
        : dateCursor < dateSortedSongs.length
    }

    function updateLoadStatus() {
      const status = document.getElementById('songs-load-status')
      if (!(status instanceof HTMLElement)) return
      if (getActiveSongs().length === 0) {
        status.textContent = ''
        return
      }
      status.textContent = hasMore() ? '继续下滑以加载更多…' : '已加载全部内容'
    }

    function loadMoreActiveMode() {
      if (activeMode === 'plays') {
        loadNextPlayBatch(clickMap)
      } else {
        loadNextDateBatch(clickMap)
      }
      updateLoadStatus()
    }

    function setupObserver() {
      if (observer) {
        observer.disconnect()
        observer = null
      }

      const sentinel = document.getElementById('songs-load-sentinel')
      if (!(sentinel instanceof HTMLElement)) return
      if (typeof IntersectionObserver !== 'function') return

      observer = new IntersectionObserver(
        (entries) => {
          if (entries[0]?.isIntersecting) loadMoreActiveMode()
        },
        { root: null, rootMargin: '240px', threshold: 0 }
      )
      observer.observe(sentinel)
    }

    function fillViewport() {
      let guard = 0
      while (hasMore() && guard < 4 && document.documentElement.scrollHeight <= window.innerHeight + 120) {
        loadMoreActiveMode()
        guard += 1
      }
    }

    function applySort(mode, map = clickMap) {
      activeMode = mode === 'plays' ? 'plays' : 'date'
      const activeSongs = getActiveSongs()
      if (activeMode === 'plays') {
        playSortedSongs = [...activeSongs].sort((a, b) => {
          const countDiff = getCountBySong(b, map) - getCountBySong(a, map)
          if (countDiff !== 0) return isReverseOrder ? -countDiff : countDiff
          const timeDiff = b.collectTs - a.collectTs
          return isReverseOrder ? -timeDiff : timeDiff
        })
        showPlaySortedFlat()
        resetPlayRender(map)
      } else {
        dateSortedSongs = isReverseOrder ? [...activeSongs].reverse() : activeSongs
        showDateGroups()
        resetDateRender(map)
      }

      setSortUI(activeMode)
      updateLoadStatus()
      setupObserver()
      fillViewport()
    }

    async function addTagToSource(songId, tag) {
      const res = await fetch(TAG_API, {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          accept: 'application/json'
        },
        body: JSON.stringify({ songId, tag })
      })

      let payload = null
      try {
        payload = await res.json()
      } catch {
        // ignore
      }

      if (!res.ok) {
        const message = payload?.message || `Add tag failed: ${res.status}`
        throw new Error(message)
      }

      return payload
    }

    function syncSongTagInMemory(songId, tag) {
      const target = SONGS.find((song) => song.id === songId)
      if (!target) return

      if (!Array.isArray(target.tags)) {
        target.tags = [tag]
        return
      }

      const existed = target.tags.some(
        (value) => String(value).toLowerCase() === String(tag).toLowerCase()
      )
      if (!existed) target.tags.push(tag)
    }

    async function loadClicksFromCloud() {
      const ids = getSongIds()
      if (ids.length === 0) return {}

      const CHUNK_SIZE = 200
      const merged = {}

      for (let i = 0; i < ids.length; i += CHUNK_SIZE) {
        const chunk = ids.slice(i, i + CHUNK_SIZE)
        const res = await fetch(STATS_API, {
          method: 'POST',
          headers: {
            'content-type': 'application/json',
            accept: 'application/json'
          },
          body: JSON.stringify({ ids: chunk })
        })
        if (!res.ok) throw new Error(`Load stats failed: ${res.status}`)

        const data = await res.json()
        if (data && typeof data === 'object') {
          Object.assign(merged, data)
        }
      }

      return merged
    }

    async function incClickCloud(songId) {
      const res = await fetch(STATS_API, {
        method: 'POST',
        keepalive: true,
        headers: {
          'content-type': 'application/json'
        },
        body: JSON.stringify({ songId })
      })
      if (!res.ok) throw new Error(`Increase stats failed: ${res.status}`)

      const data = await res.json()
      const plays = Number(data?.plays ?? 0)
      clickMap[songId] = Number.isFinite(plays) ? plays : 0
    }

    function updateUIFromMap(map = clickMap) {
      clickMap = map
      updateTotalText(map)
      updateVisibleCounts(map)
      if (activeMode === 'plays') {
        applySort('plays', map)
      }
    }

    async function updateUI() {
      try {
        clickMap = await loadClicksFromCloud()
      } catch {
        const totalEl = document.getElementById('total-clicks')
        if (totalEl) totalEl.textContent = '云端未连接'
        return
      }
      updateUIFromMap(clickMap)
    }

    document.addEventListener('click', async (e) => {
      const target = e.target
      if (!(target instanceof Element)) return

      const tagAction = target.closest('button[data-tag-action]')
      if (tagAction instanceof HTMLButtonElement) {
        e.preventDefault()
        e.stopPropagation()

        const sourceId = String(tagAction.dataset.songSourceId ?? '').trim()
        if (!sourceId) return

        const value = window.prompt('输入要添加的标签')
        const nextTag = String(value ?? '').trim()
        if (!nextTag) return

        try {
          const result = await addTagToSource(sourceId, nextTag)
          if (result?.added) {
            syncSongTagInMemory(sourceId, nextTag)
            applySearch(searchQuery)
            window.alert(`已添加标签：${nextTag}`)
          } else {
            window.alert('该标签已存在，无需重复添加。')
          }
        } catch (err) {
          window.alert(String((err && err.message) || err || '添加标签失败'))
        }
        return
      }

      const tagReset = target.closest('a[data-tag-reset]')
      if (tagReset instanceof HTMLAnchorElement) {
        e.preventDefault()
        tagFilterState = new Map()
        updateTagFilterUI()
        applySearch(searchQuery)
        return
      }

      const tagControl = target.closest('a[data-filter-tag]')
      if (tagControl instanceof HTMLAnchorElement) {
        e.preventDefault()
        const tag = String(tagControl.getAttribute('data-filter-tag') ?? '').trim()
        if (!tag) return

        const currentState = Number(tagFilterState.get(tag) ?? 0)
        const nextState = currentState === 0 ? 1 : currentState === 1 ? -1 : 0
        if (nextState === 0) tagFilterState.delete(tag)
        else tagFilterState.set(tag, nextState)

        updateTagFilterUI()
        applySearch(searchQuery)
        return
      }

      const sortControl = target.closest('a[data-sort-mode]')
      if (sortControl instanceof HTMLAnchorElement) {
        e.preventDefault()
        const mode = sortControl.getAttribute('data-sort-mode') === 'plays' ? 'plays' : 'date'
        if (mode === activeMode) isReverseOrder = !isReverseOrder
        else isReverseOrder = false
        saveSortMode(mode)
        applySort(mode, clickMap)
        return
      }

      const link = target.closest('a[data-song-id]')
      if (!(link instanceof HTMLAnchorElement)) return

      const songId = link.getAttribute('data-song-id')
      if (!songId) return

      try {
        await incClickCloud(songId)
        updateUIFromMap(clickMap)
      } catch {
        const totalEl = document.getElementById('total-clicks')
        if (totalEl) totalEl.textContent = '云端写入失败'
      }
    })

    document.addEventListener('DOMContentLoaded', () => {
      const searchInput = document.getElementById('songs-search-input')
      if (searchInput instanceof HTMLInputElement) {
        searchInput.addEventListener('input', () => {
          applySearch(searchInput.value)
        })
      }

      updateTagFilterUI()
      applySearch(searchInput instanceof HTMLInputElement ? searchInput.value : '')

      const mode = loadSortMode()
      applySort(mode, clickMap)
      updateUI()
    })
  </script>

  <style>
    :global(.song-grid) {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(1, minmax(0, 1fr));
    }

    @media (min-width: 640px) {
      :global(.song-grid) {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (min-width: 768px) {
      :global(.song-grid) {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (min-width: 1024px) {
      :global(.song-grid) {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }

    @media (min-width: 1280px) {
      :global(.song-grid) {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }

    :global(#main-container) {
      max-width: 96rem;
      padding-left: calc(0.75rem + env(safe-area-inset-left));
      padding-right: calc(0.75rem + env(safe-area-inset-right));
    }

    @media (min-width: 640px) {
      :global(#main-container) {
        padding-left: calc(1.25rem + env(safe-area-inset-left));
        padding-right: calc(1.25rem + env(safe-area-inset-right));
      }
    }

    @media (min-width: 1024px) {
      :global(#main-container) {
        padding-left: calc(1.5rem + env(safe-area-inset-left));
        padding-right: calc(1.5rem + env(safe-area-inset-right));
      }
    }
  </style>
</PageLayout>
